1.Data reading

Source file content：

#include "fvCFD.H"

int main(int argc, char *argv[])
{
#include "setRootCase.H"
#include "createTime.H"
#include "createMesh.H"

	IOdictionary custrmProperties
		(
		 IOobject
		 (
		 "custrmProperties",
		 runTime.constant(),
		 mesh,
		 IOobject::MUST_READ,
		 IOobject::NO_WRITE
		 )
		);
	word someword;
	custrmProperties.lookup("someword") >> someword;

	scalar someScalar(custrmProperties.lookupOrDefault<scalar>("someScalar",1.0));

	List<scalar> someList(custrmProperties.lookup("someList"));

	HashTable<vector,word> someHashTable(custrmProperties.lookup("someHashTable"));

	bool someBool(custrmProperties.lookupOrDefault<Switch>("someBool",true));

	Info << nl <<"读取的数据是："<< endl
		<<"someword:" <<someword <<endl
		<<"someScalar:"<<someScalar<<endl
		<<"someList:" <<  someList << endl
		<< "someHashTable:" <<  someHashTable << endl
		<< "someBool:" << someBool << endl;
	Info <<endl;

	return 0;

}

Make/files file contents：

demo1.C

EXE = demo1

Make/options file contents：

EXE_INC = \
       -I$(FOAM_SRC)/finiteVolume/lnInclude \
       -I$(FOAM_SRC)/meshTools/lnInclude

EXE_LIBS = \
         -lfiniteVolume \ 
         -lmeshTools

Case:./constant/custrmProperties file contents：

/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  6
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "constant";
    object      custrmProperties;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

someword myword;
someScalar 0.02;
someBool off;
someList (0 1 2 3 4 5);
someHashTable
(
  key0 (0 0 0)
  key1 (1 0 0)
);


2.Data write

Source file content：

#include "fvCFD.H"

int main(int argc, char *argv[])
{
#include "setRootCase.H"
#include "createTime.H"
#include "createMesh.H"
fileName outputDir = mesh.time().path() / "postProcessing";
mkDir(outputDir);
autoPtr<OFstream> outputFilePtr;
outputFilePtr.reset(new OFstream(outputDir / "custrmFile.txt"));
outputFilePtr() << "开始写入："<< endl;
outputFilePtr() << "0 1 2 3 4 5"<< endl;
HashTable<vector,word> someHashTable;
someHashTable.insert("row 1", vector(1,0,0));
someHashTable.insert("row 2", vector(0,1,0));
someHashTable.insert("row 3", vector(0,0,1));
//someHashTable.insert("row 4", word(zh));
outputFilePtr() <<someHashTable<< endl;
Info << "文件写入成功" << endl;


	return 0;

}


Make/files file contents：

demo1A.C

EXE = demo1A

Make/options file contents：

EXE_INC = \
       -I$(FOAM_SRC)/finiteVolume/lnInclude \
       -I$(FOAM_SRC)/meshTools/lnInclude

EXE_LIBS = \
         -lfiniteVolume \ 
         -lmeshTools

Case:./postProcessing/custrmFile.txt file contents：

开始写入：
0 1 2 3 4 5

3
(
row 1 (1 0 0)
row 2 (0 1 0)
row 3 (0 0 1)
)

3.获得网格基本信息及计算每个边界patch的总面积：

#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"
	#include "createMesh.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
	//1
	label fcs = mesh.faces().size();
	label pts = mesh.points().size();
        Foam::Info <<"当前时间：" << runTime.timeName() <<endl
	             <<"网格点共有："<<pts<<endl
	             <<"网格面共有："<<fcs<<endl
			  <<"网格单元共有：" <<mesh.C().size() << endl
			  <<"内部网格面共有："<< mesh.Cf().size() <<endl
			  <<"边界网格面共有："<<fcs-mesh.Cf().size() <<endl;
			  Info <<nl;  
	//2
    for (label patchi =0; patchi<mesh.boundary().size(); patchi++)
	{
 Foam::Info<<"边界patch[" << patchi <<"]的name是：" <<mesh.boundary()[patchi].name() <<endl
			<<"其包含网格面的数量是：" << mesh.boundary()[patchi].Cf().size() <<endl;
			
			double sum =0.0;
			
		for(label patchfacei=0; patchfacei<mesh.boundary()[patchi].Cf().size(); patchfacei++)
		{

			Foam::Info<<"其网格面patchface["<<patchfacei<<"]的面积矢量是："<<mesh.boundary()[patchi].Sf()[patchfacei]<<",其面积为："<<mag(mesh.boundary()[patchi].Sf()[patchfacei])<<endl;
			
			sum+=mag(mesh.boundary()[patchi].Sf()[patchfacei]);
		}
		Foam::Info<<"该patch["<<patchi<<"]上的网格面总面积是："<<sum<<endl;
		Info <<nl;
	}

    return 0;
}

4.获取网格单元的体心坐标：

#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"
	#include "createMesh.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
	//1
   forAll(mesh.C(),celli)
	{
		Foam::Info<<"网格单元[" << celli <<"]的体心坐标是：" <<mesh.C()[celli] <<endl;
	}

    return 0;
}


5.获取owner,neighbour的信息（owner的信息获取不全，不知原因）：
#include "fvCFD.H"

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"
	#include "createMesh.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
	//1
            forAll(mesh.owner(),ocelli)
	{
		Foam::Info<<"总网格面[" << ocelli<<"]的owner网格单元的序号是：" <<mesh.owner()[ocelli] <<endl;
	}
	
	     forAll(mesh.neighbour(),ncellI)
	{
		Foam::Info<<"内部网格面[" << ncellI <<"]的neighbour网格单元的序号是：" <<mesh.neighbour()[ncellI] <<endl;
	}

    return 0;
}


6.获取边界上的网格面与哪一个网格单元对应的信息：

#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"
	#include "createMesh.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
	//1

    for (label patchi =0; patchi<mesh.boundary().size(); patchi++)
	{
 Foam::Info<<"边界patch[" << patchi <<"]的name是：" <<mesh.boundary()[patchi].name() <<endl
			<<"其包含网格面的数量是：" << mesh.boundary()[patchi].Cf().size() <<endl;
			
			
			
		for(label patchfacei=0; patchfacei<mesh.boundary()[patchi].Cf().size(); patchfacei++)
		{
          Foam::Info<<"边界patch[" << patchi <<"]上的网格面" <<patchfacei<<"与网格单元"<<mesh.boundary()[patchi].patch().faceCells()[patchfacei]<<"对应" <<endl;
	
		}
		
		Info <<nl;
	}
    return 0;
}

7.获取网格面，网格点，网格面中心节点坐标信息：

#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"
	#include "createMesh.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
	//1

	const faceList &fcs = mesh.faces();
	const List<point> &pts = mesh.points();
	const List<point> &cents = mesh.faceCentres();
	forAll(fcs,facei)
	{
		Foam::Info<<"第["<<facei<<"]个网格面由该点集合组成："<<fcs[facei]<<endl;
	}
	Info<<nl<<nl;
	forAll(pts,pointi)
	{
		Foam::Info<<"第["<<pointi<<"]个网格点的坐标是："<<pts[pointi]<<endl;
	}
	Info<<nl<<nl;
	forAll(cents,celli)
	{
		Foam::Info<<"第["<<celli<<"]个网格面中心节点坐标信息是："<<cents[celli]<<endl;
	}
    return 0;
}

8.输出每个网格面的归属信息（边界面还是内部面），且输出该面上的许多信息（中心坐标，包含的网格点数量及点的坐标）


#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"
	#include "createMesh.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
	//1
	const faceList &fcs = mesh.faces();
	const List<point> &pts = mesh.points();
	const List<point> &cents = mesh.faceCentres();
			  
	forAll(fcs,facei)
	{
		if(facei<=mesh.Cf().size())
		{
			Foam::Info<<"网格面face["<<facei<<"]"<<"是内部面。"<<endl;
		}
		else
		{
			forAll(mesh.boundary(),patchi)
			{
				if((mesh.boundary()[patchi].start()<facei) && (facei<mesh.boundary()[patchi].start()+mesh.boundary()[patchi].Cf().size()))
				{
					Foam::Info<<"网格面face["<<facei<<"]"<<"在边界patch["<<patchi<<"]上"<<endl;
					break;
				}
			}
			
		}
		
		Foam::Info<<"网格面face["<<facei<<"]的网格中心坐标是："<<cents[facei]<<endl
		<<"其拥有网格点的数量是："<<fcs[facei].size()<<endl;
		
		Foam::Info<<"其网格点坐标是：";
		forAll(fcs[facei],vertexi)
		{
			
			Info<<pts[fcs[facei][vertexi]]<<",";
		}
		Foam::Info<<nl<<nl;
	}
    return 0;
}

9.